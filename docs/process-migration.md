### üöÄ Migration process

The modernization process was structured into 8 strategic phases, specifically tailored to meet the technical requirements of the payment orders module.

It is worth noting that this process was executed using an AI-Assisted Development approach, optimizing code generation and refactoring, and testing. Detailed evidence and the prompts used can be found in the (Use of artificial intelligence) section.


#### ‚ñ∂Ô∏è Phase 1: WSDL Analysis

In this phase, we proceeded to analyze the file provided for the migration (PaymentOrderService.wsdl), where we used AI to indicate all the points we required in the analysis to have a general perspective of what the SOAP service does.

#### ‚ñ∂Ô∏è Phase 2: Rest API Design

In this phase, the analysis generated by the AI is used to ask it to generate a REST API design that we could build.

#### ‚Üí Manual Changes
Based on the AI's response, some changes will be made to the design, both to the endpoints and the field names for the entities, in order to make it similar to the examples provided in the Postman collection.

#### ‚ñ∂Ô∏è Phase 3: Creating the file with OpenApi 3.0

In this phase, the analysis generated by the AI is used to ask it to generate the `openapi.yaml` file, which we will use for the creation of the Rest API.

#### ‚ñ∂Ô∏è Phase 4: Project generation with Spring Boot

The Spring Boot 4.0.2 project was created using the Spring Initializer website ([link](https://start.spring.io/)), with the following configuration:
* Spring Boot version: 4.0.2
* Package manager: Maven
* Packaging: JAR
* Configuration file: Properties
* Java version: 21

The dependencies added are shown below:

![dependencies](/docs/images/phase4/1.create-spring-boot-project.png)

Additionally, the Open API Generator plugin ([link](https://openapi-generator.tech/docs/plugins/)) was manually added to generate code based on the YAML file obtained in the previous step.

```
               <plugin>
				<groupId>org.openapitools</groupId>
				<artifactId>openapi-generator-maven-plugin</artifactId>
				<version>7.17.0</version>
				<executions>
					<execution>
						<goals>
							<goal>generate</goal>
						</goals>
						<configuration>
							<inputSpec>${project.basedir}/src/main/resources/openapi.yaml</inputSpec>
							<generatorName>spring</generatorName>
							<apiPackage>com.demo.payment_order_service.infrastructure.adapter.in.rest.api</apiPackage>
							<modelPackage>com.demo.payment_order_service.infrastructure.adapter.in.rest.dto</modelPackage>
							<library>spring-boot</library>
							<configOptions>
								<interfaceOnly>true</interfaceOnly>
								<useSpringBoot3>true</useSpringBoot3>
								<skipDefaultInterface>true</skipDefaultInterface>
								<useTags>true</useTags>
								<useBeanValidation>true</useBeanValidation>
								<performBeanValidation>true</performBeanValidation>
								<hideGenerationTimestamp>true</hideGenerationTimestamp>
							</configOptions>
						</configuration>
					</execution>
				</executions>
			</plugin>
```

#### ‚ñ∂Ô∏è Phase 5: Apply Hexagonal architecture

In this phase, the AI was asked to help us design a hexagonal architecture based on all the previously analyzed data and the project's current structure. Once the design was reviewed, the AI was asked to implement it, applying all best practices and without using the Spring framework in the domain.

#### ‚Üí Manual Changes

The generation of the Payment Order ID was manually adjusted so that it does not use a full UUID but shortens it to 4 characters and also concatenates it with ‚ÄúPO-‚Äù as in the examples provided.


#### ‚ñ∂Ô∏è Phase 6: Docker for database initialization

In this phase, a Docker Compose file was created to start the environment. This file references a PostgreSQL database and also allows the application to run. To run the application, a Dockerfile was created based on the `eclipse-temurin:21-jre-jammy` image to run the application with the corresponding Java version.
The entire process of compiling, generating the Docker image, and starting the environment is done using the `start.sh` file, which contains all the necessary steps to have the environment ready for application validation.

#### ‚ñ∂Ô∏è Phase 7: Test creation

In this phase, we proceeded to ask the AI to help us create the unit and integration tests respecting the hexagonal architecture and the contract-first of OpenAPI.

#### ‚Üí Manual Changes

In this phase, some test classes had to be adjusted due to issues with imports and dependency management. The changes to the tests were reviewed, and the AI was asked to adjust them based on the findings.

#### ‚ñ∂Ô∏è Phase 8: Code coverage and code coverage reports (Jacoco)

Finally, in this phase, integration with Jacoco was added to be able to view code coverage reports.


